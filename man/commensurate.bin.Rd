% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/commensurate.bin.R
\name{commensurate.bin}
\alias{commensurate.bin}
\title{Commensurate power prior: binary outcome}
\usage{
commensurate.bin(
  formula, data, method.borrow,
  chains=2, iter=4000, warmup=floor(iter/2), thin=1,
  alternative="greater", sig.level=0.025,
  seed=sample.int(.Machine$integer.max,1))
}
\arguments{
\item{formula}{formula.}

\item{data}{data.}

\item{method.borrow}{List of information borrowing method. \code{"noborrow"}
uses the concurrent data only. \code{"fullborrow"} uses the external control
data without discounting. \code{"cauchy"} uses the commensurate prior to
dynamically borrow the external control data, and the commensurate parameter
is assumed to follow half-Cauchy distribution. \code{"normal"} uses the
commensurate prior to dynamically borrow the external control data, and the
commensurate parameter is assumed to follow half-normal distribution.
\code{"cauchy"} and \code{"normal"} require to specify the scale parameter of
half-Cauchy and half-normal distribution respectively.}

\item{chains}{Number of Markov chains in MCMC sampling. The default value is
\code{chains=2}.}

\item{iter}{Number of iterations for each chain (including warmup) in MCMC
sampling. The default value is \code{iter=4000}.}

\item{warmup}{Number of warmup (aka burnin) iterations per chain in MCMC
sampling. The default value is \code{warmup=floor(iter/2)}.}

\item{thin}{Period for saving samples in MCMC sampling. The default value
is \code{thin=1}.}

\item{alternative}{Alternative hypothesis to be tested ("greater" or "less").
The default value is \code{alternative="greater"}.}

\item{sig.level}{Significance level. The default value is
\code{sig.level=0.025}.}

\item{seed}{seed.}
}
\value{
\item{reject}{\code{TRUE} when significant; otherwise \code{FALSE}.}
\item{theta}{Posterior mean, median, and sd of log odds ratio.}
}
\description{
Commensurate power prior is implemented. No borrowing and full borrowing are
also implemented. The binary outcome is applicable.
}
\examples{
n.CT  <- 100
n.CC  <- 50
n.ECp <- 1000

out.prob.CT <- 0.2
out.prob.CC <- 0.2
driftOR     <- 1.0

cov.C <- list(list(dist="norm",mean=0,sd=1),
              list(dist="binom",prob=0.4))

cov.cor.C <- rbind(c(  1,0.1),
                   c(0.1,  1))

cov.effect.C <- c(0.1,0.1)

cov.EC <- list(list(dist="norm",mean=0,sd=1),
               list(dist="binom",prob=0.4))

cov.cor.EC <- rbind(c(  1,0.1),
                    c(0.1,  1))

cov.effect.EC <- c(0.1,0.1)

indata <- trial.simulation.bin(
  n.CT=n.CT, n.CC=n.CC, n.ECp=n.ECp,
  out.prob.CT=out.prob.CT, out.prob.CC=out.prob.CC, driftOR=driftOR,
  cov.C=cov.C, cov.cor.C=cov.cor.C, cov.effect.C=cov.effect.C,
  cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect.EC=cov.effect.EC)

n.EC <- 50

method.whomatch <- "conc.treat"
method.matching <- "optimal"
method.psorder  <- NULL

out.psmatch <- psmatch(
  study~X1+X2, data=indata, n.EC=n.EC,
  method.whomatch=method.whomatch, method.matching=method.matching,
  method.psorder=method.psorder)

indata.match <- rbind(indata[indata$study==1,],indata[out.psmatch$subjid.EC,])

method.borrow <- list(list(prior="noborrow"),
                      list(prior="fullborrow"),
                      list(prior="cauchy",scale=2.0),
                      list(prior="normal",scale=0.5))

commensurate.bin(y~X1+X2,data=indata.match,method.borrow=method.borrow)
}
