% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/commensurate.t2e.R
\name{commensurate.t2e}
\alias{commensurate.t2e}
\title{Commensurate power prior: time-to-event outcome}
\usage{
commensurate.t2e(
  indata, subjid.EC, method.borrow,
  chains=2, iter=4000, warmup=floor(iter/2), thin=1,
  alternative="greater", sig.level=0.025)
}
\arguments{
\item{indata}{Dataset of a simulated trial, which is a data frame returned
from \code{trial.simulation.t2e}, \code{trial.simulation.bin}, or
\code{trial.simulation.cont}.}

\item{subjid.EC}{Subject ID of external control.}

\item{method.borrow}{List of information borrowing method. \code{"noborrow"}
uses the concurrent data only. \code{"fullborrow"} uses the external control
data without discounting. \code{"cauchy"} uses the commensurate prior to
dynamically borrow the external control data, and the commensurate parameter
is assumed to follow half-Cauchy distribution. \code{"normal"} uses the
commensurate prior to dynamically borrow the external control data, and the
commensurate parameter is assumed to follow half-normal distribution.
\code{"cauchy"} and \code{"normal"} require to specify the scale parameter of
half-Cauchy and half-normal distribution respectively.}

\item{chains}{Number of Markov chains in MCMC sampling. The default value is
\code{chains=2}.}

\item{iter}{Number of iterations for each chain (including warmup) in MCMC
sampling. The default value is \code{iter=4000}.}

\item{warmup}{Number of warmup (burnin) iterations per chain in MCMC
sampling. The default value is \code{warmup=floor(iter/2)}.}

\item{thin}{Period for saving samples in MCMC sampling. The default value
is \code{thin=1}.}

\item{alternative}{Alternative hypothesis to be tested ("greater" or "less").
The default value is \code{alternative="greater"}.}

\item{sig.level}{Significance level. The default value is
\code{sig.level=0.025}.}
}
\value{
\item{reject}{\code{TRUE} when significant; otherwise \code{FALSE}.}
\item{theta}{Posterior mean, median, and sd of log hazard ratio.}
}
\description{
Commensurate power prior is implemented. No borrowing and full borrowing are
also implemented. The time-to-event outcome is applicable.
}
\examples{
n.CT       <- 100
n.CC       <- 50
nevent.C   <- 100
n.ECp      <- 1000
nevent.ECp <- 800
accrual    <- 16

out.mevent.CT <- 6
out.mevent.CC <- 6
driftHR       <- 1

cov.C <- list(list(dist="norm",mean=0,sd=1),
              list(dist="binom",prob=0.4))

cov.cor.C <- rbind(c(  1,0.1),
                   c(0.1,  1))

cov.effect.C <- c(0.1,0.1)

cov.EC <- list(list(dist="norm",mean=0,sd=1),
               list(dist="binom",prob=0.4))

cov.cor.EC <- rbind(c(  1,0.1),
                    c(0.1,  1))

cov.effect.EC <- c(0.1,0.1)

indata <- trial.simulation.t2e(
  n.CT=n.CT, n.CC=n.CC, nevent.C=nevent.C,
  n.ECp=n.ECp, nevent.ECp=nevent.ECp, accrual=accrual,
  out.mevent.CT, out.mevent.CC, driftHR,
  cov.C=cov.C, cov.cor.C=cov.cor.C, cov.effect.C=cov.effect.C,
  cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect.EC=cov.effect.EC)

n.EC <- 50

method.whomatch <- "conc.treat"
method.matching <- "optimal"
method.psorder  <- NULL

out.psmatch <- psmatch(
  indata=indata, n.EC=n.EC,
  method.whomatch=method.whomatch, method.matching=method.matching,
  method.psorder=method.psorder)

subjid.EC <- out.psmatch$subjid.EC

method.borrow <- list(list(prior="noborrow"),
                      list(prior="normal",scale=0.5))

commensurate.t2e(
  indata=indata, subjid.EC=subjid.EC, method.borrow=method.borrow)
}
