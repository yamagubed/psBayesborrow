yCT_o = as.array(data.CT[censor.CT==0,1]),
yCT_c = as.array(data.CT[censor.CT==1,1]),
yCC_o = as.array(data.CC[censor.CC==0,1]),
yCC_c = as.array(data.CC[censor.CC==1,1]),
yEC_o = as.array(data.EC[censor.EC==0,1]),
yEC_c = as.array(data.EC[censor.EC==1,1]),
xCT_o = matrix(as.matrix(data.CT[censor.CT==0,-1]),sum(censor.CT==0),ncov),
xCT_c = matrix(as.matrix(data.CT[censor.CT==1,-1]),sum(censor.CT==1),ncov),
xCC_o = matrix(as.matrix(data.CC[censor.CC==0,-1]),sum(censor.CC==0),ncov),
xCC_c = matrix(as.matrix(data.CC[censor.CC==1,-1]),sum(censor.CC==1),ncov),
xEC_o = matrix(as.matrix(data.EC[censor.EC==0,-1]),sum(censor.EC==0),ncov),
xEC_c = matrix(as.matrix(data.EC[censor.EC==1,-1]),sum(censor.EC==1),ncov),
scale = method.borrow[[i]]$scale)
mcmc <- rstan::sampling(stanmodels$T2ECauchy,
data          = dat,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0)
mcmc.sample <- rstan::extract(mcmc)
}else if(method.borrow[[i]]$prior=="normal"){
dat <- list(
nCT_o = sum(censor.CT==0),
nCT_c = sum(censor.CT==1),
nCC_o = sum(censor.CC==0),
nCC_c = sum(censor.CC==1),
nEC_o = sum(censor.EC==0),
nEC_c = sum(censor.EC==1),
p     = ncov,
yCT_o = as.array(data.CT[censor.CT==0,1]),
yCT_c = as.array(data.CT[censor.CT==1,1]),
yCC_o = as.array(data.CC[censor.CC==0,1]),
yCC_c = as.array(data.CC[censor.CC==1,1]),
yEC_o = as.array(data.EC[censor.EC==0,1]),
yEC_c = as.array(data.EC[censor.EC==1,1]),
xCT_o = matrix(as.matrix(data.CT[censor.CT==0,-1]),sum(censor.CT==0),ncov),
xCT_c = matrix(as.matrix(data.CT[censor.CT==1,-1]),sum(censor.CT==1),ncov),
xCC_o = matrix(as.matrix(data.CC[censor.CC==0,-1]),sum(censor.CC==0),ncov),
xCC_c = matrix(as.matrix(data.CC[censor.CC==1,-1]),sum(censor.CC==1),ncov),
xEC_o = matrix(as.matrix(data.EC[censor.EC==0,-1]),sum(censor.EC==0),ncov),
xEC_c = matrix(as.matrix(data.EC[censor.EC==1,-1]),sum(censor.EC==1),ncov),
scale = method.borrow[[i]]$scale)
mcmc <- rstan::sampling(stanmodels$T2ENormal,
data          = dat,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0)
mcmc.sample <- rstan::extract(mcmc)
}
}else if(sum(censor.CC==1)==0){
if(method.borrow[[i]]$prior=="noborrow"){
dat <- list(
nCT_o = sum(censor.CT==0),
nCT_c = sum(censor.CT==1),
nCC_o = sum(censor.CC==0),
p     = ncov,
yCT_o = as.array(data.CT[censor.CT==0,1]),
yCT_c = as.array(data.CT[censor.CT==1,1]),
yCC_o = as.array(data.CC[censor.CC==0,1]),
xCT_o = matrix(as.matrix(data.CT[censor.CT==0,-1]),sum(censor.CT==0),ncov),
xCT_c = matrix(as.matrix(data.CT[censor.CT==1,-1]),sum(censor.CT==1),ncov),
xCC_o = matrix(as.matrix(data.CC[censor.CC==0,-1]),sum(censor.CC==0),ncov))
mcmc <- rstan::sampling(stanmodels$T2ENoborrowC0,
data          = dat,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0)
mcmc.sample <- rstan::extract(mcmc)
}else if(method.borrow[[i]]$prior=="fullborrow"){
dat <- list(
nCT_o = sum(censor.CT==0),
nCT_c = sum(censor.CT==1),
nCC_o = sum(censor.CC==0),
nEC_o = sum(censor.EC==0),
nEC_c = sum(censor.EC==1),
p     = ncov,
yCT_o = as.array(data.CT[censor.CT==0,1]),
yCT_c = as.array(data.CT[censor.CT==1,1]),
yCC_o = as.array(data.CC[censor.CC==0,1]),
yEC_o = as.array(data.EC[censor.EC==0,1]),
yEC_c = as.array(data.EC[censor.EC==1,1]),
xCT_o = matrix(as.matrix(data.CT[censor.CT==0,-1]),sum(censor.CT==0),ncov),
xCT_c = matrix(as.matrix(data.CT[censor.CT==1,-1]),sum(censor.CT==1),ncov),
xCC_o = matrix(as.matrix(data.CC[censor.CC==0,-1]),sum(censor.CC==0),ncov),
xEC_o = matrix(as.matrix(data.EC[censor.EC==0,-1]),sum(censor.EC==0),ncov),
xEC_c = matrix(as.matrix(data.EC[censor.EC==1,-1]),sum(censor.EC==1),ncov))
mcmc <- rstan::sampling(stanmodels$T2EFullborrowC0,
data          = dat,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0)
mcmc.sample <- rstan::extract(mcmc)
}else if(method.borrow[[i]]$prior=="cauchy"){
dat <- list(
nCT_o = sum(censor.CT==0),
nCT_c = sum(censor.CT==1),
nCC_o = sum(censor.CC==0),
nEC_o = sum(censor.EC==0),
nEC_c = sum(censor.EC==1),
p     = ncov,
yCT_o = as.array(data.CT[censor.CT==0,1]),
yCT_c = as.array(data.CT[censor.CT==1,1]),
yCC_o = as.array(data.CC[censor.CC==0,1]),
yEC_o = as.array(data.EC[censor.EC==0,1]),
yEC_c = as.array(data.EC[censor.EC==1,1]),
xCT_o = matrix(as.matrix(data.CT[censor.CT==0,-1]),sum(censor.CT==0),ncov),
xCT_c = matrix(as.matrix(data.CT[censor.CT==1,-1]),sum(censor.CT==1),ncov),
xCC_o = matrix(as.matrix(data.CC[censor.CC==0,-1]),sum(censor.CC==0),ncov),
xEC_o = matrix(as.matrix(data.EC[censor.EC==0,-1]),sum(censor.EC==0),ncov),
xEC_c = matrix(as.matrix(data.EC[censor.EC==1,-1]),sum(censor.EC==1),ncov),
scale = method.borrow[[i]]$scale)
mcmc <- rstan::sampling(stanmodels$T2ECauchyC0,
data          = dat,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0)
mcmc.sample <- rstan::extract(mcmc)
}else if(method.borrow[[i]]$prior=="normal"){
dat <- list(
nCT_o = sum(censor.CT==0),
nCT_c = sum(censor.CT==1),
nCC_o = sum(censor.CC==0),
nEC_o = sum(censor.EC==0),
nEC_c = sum(censor.EC==1),
p     = ncov,
yCT_o = as.array(data.CT[censor.CT==0,1]),
yCT_c = as.array(data.CT[censor.CT==1,1]),
yCC_o = as.array(data.CC[censor.CC==0,1]),
yEC_o = as.array(data.EC[censor.EC==0,1]),
yEC_c = as.array(data.EC[censor.EC==1,1]),
xCT_o = matrix(as.matrix(data.CT[censor.CT==0,-1]),sum(censor.CT==0),ncov),
xCT_c = matrix(as.matrix(data.CT[censor.CT==1,-1]),sum(censor.CT==1),ncov),
xCC_o = matrix(as.matrix(data.CC[censor.CC==0,-1]),sum(censor.CC==0),ncov),
xEC_o = matrix(as.matrix(data.EC[censor.EC==0,-1]),sum(censor.EC==0),ncov),
xEC_c = matrix(as.matrix(data.EC[censor.EC==1,-1]),sum(censor.EC==1),ncov),
scale = method.borrow[[i]]$scale)
mcmc <- rstan::sampling(stanmodels$T2ENormalC0,
data          = dat,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0)
mcmc.sample <- rstan::extract(mcmc)
}
}
loghr <- mcmc.sample$theta
if(alternative=="greater"){
postprob <- mean(loghr>0)
}else if(alternative=="less"){
postprob <- mean(loghr<0)
}
cri <- quantile(loghr,c(sig.level,1-sig.level))
reject.v <- (postprob>(1-sig.level))
reject   <- data.frame(reject,X1=reject.v)
theta.v <- c(mean(loghr),median(loghr),sd(loghr),cri[[1]],cri[[2]])
theta   <- data.frame(theta,X1=theta.v)
mname <- method.borrow[[i]]$prior
if((mname=="noborrow")|(mname=="fullborrow")){
method.lab[i] <- mname
}else if((mname=="cauchy")|(mname=="normal")){
method.lab[i] <- paste(mname,method.borrow[[i]]$scale)
}
}
colnames(reject) <- c("measure",mname)
colnames(theta)  <- c("measure",mname)
return(list(reject=reject,theta=theta))
}
out.commensurate <- commensurate.t2e(
indata=indata, subjid.EC=subjid.EC, method.borrow=method.borrow,
chains=chains, iter=iter, warmup=warmup, thin=thin,
alternative=alternative, sig.level=sig.level)
library(psBayesborrow)
library(psBayesborrow)
library(psBayesborrow)
aa<-rbing(c(TRUE,TRUE),
c(FALSE,FALSE))
aa<-rbind(c(TRUE,TRUE),
c(FALSE,FALSE))
aa
aa<-rbind(c(TRUE,TRUE),
c(FALSE,FALSE))
bb<-rbind(c(TRUE,TRUE),
c(TRUE,FALSE))
aa*bb
library(psBayesborrow)
library(psBayesborrow)
library(psBayesborrow)
library(psBayesborrow)
library(psBayesborrow)
psborrow.summary
library(psBayesborrow)
n.CT       <- 100
n.CC       <- 50
nevent.C   <- 100
n.ECp      <- 1000
nevent.ECp <- 800
n.EC       <- 50
accrual    <- 16
out.mevent.CT <- 6
out.mevent.CC <- 6
driftHR       <- 1
cov.C <- list(list(dist="norm",mean=0,sd=1),
list(dist="binom",prob=0.4))
cov.cor.C <- rbind(c(  1,0.1),
c(0.1,  1))
cov.effect.C <- c(0.1,0.1)
cov.EC <- list(list(dist="norm",mean=0,sd=1),
list(dist="binom",prob=0.4))
cov.cor.EC <- rbind(c(  1,0.1),
c(0.1,  1))
cov.effect.EC <- c(0.1,0.1)
method.whomatch <- "conc.treat"
method.matching <- "optimal"
method.psorder  <- NULL
method.borrow <- list(list(prior="noborrow"),
list(prior="normal",scale=0.5))
nsim <- 100
res <- psborrow.t2e(
n.CT=n.CT, n.CC=n.CC, nevent.C=nevent.C,
n.ECp=n.ECp, nevent.ECp=nevent.ECp, n.EC=n.EC, accrual=accrual,
out.mevent.CT=out.mevent.CT, out.mevent.CC=out.mevent.CC, driftHR=driftHR,
cov.C=cov.C, cov.cor.C=cov.cor.C, cov.effect.C=cov.effect.C,
cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect.EC=cov.effect.EC,
method.whomatch=method.whomatch,
method.matching=method.matching, method.psorder=method.psorder,
method.borrow=method.borrow, nsim=100, seed=100)
psborrow.summary(res)
res$res.out
res
aa<-psborrow.summary(res)
aa
aa$res.out
x<-res
ptab1 <- rbind(
x$n.CT,
x$n.CC,
x$n.ECp,
x$n.EC,
x$drift)
rnames <- c("No. of conc. treatment",
"No. of conc. control",
"No. of ext. control pool",
"No. of ext. control",
"Prior data conflict")
dimnames(ptab1) <- list(rnames,"")
ptab1
x$res.out
x$res.out
aa$res.out
x$res.out
aa$res.out
aa$res.out
aa
aa$res.out
aa$res.out
aa$res.out[,-1]
ptab1 <- aa$res.out[,-1]
rnames <- c("Reject","Bias","EmpSD","ModSD","EmpSD/ModSD","Coverage Prob.")
dimnames(ptab1) <- list(rnames,names(aa$res.out[,-1]))
ptab1
aa$res.cov
aa$res.cov[,1]
ptab2  <- aa$res.cov[,-1]
rnames <- aa$res.cov[,1]
dimnames(ptab2) <- list(rnames,names(aa$res.cov[,-1]))
ptab2
library(psBayesborrow)
library(psBayesborrow)
print.psborrow.summary
print.psborrow.summary()
psborrow.summary
library(psBayesborrow)
n.CT       <- 100
n.CC       <- 50
n.ECp      <- 1000
out.mean.CT <- 0
out.sd.CT   <- 1
out.mean.CC <- 0
out.sd.CC   <- 1
driftdiff   <- 0
out.sd.EC   <- 1
cov.C <- list(list(dist="norm",mean=0,sd=1),
list(dist="binom",prob=0.4))
cov.cor.C <- rbind(c(  1,0.1),
c(0.1,  1))
cov.effect.C <- c(0.1,0.1)
cov.EC <- list(list(dist="norm",mean=0,sd=1),
list(dist="binom",prob=0.4))
cov.cor.EC <- rbind(c(  1,0.1),
c(0.1,  1))
cov.effect.EC <- c(0.1,0.1)
ncov        <- length(cov.C)
out.mean.EC <- driftdiff+out.mean.CC
marg.C  <- NULL
marg.EC <- NULL
mean.C  <- NULL
mean.EC <- NULL
for(i in 1:ncov){
if(cov.C[[i]]$dist=="norm"){
marg.C  <- append(marg.C, list(list(dist=cov.C[[i]]$dist, parm=list(mean=cov.C[[i]]$mean, sd=cov.C[[i]]$sd))))
marg.EC <- append(marg.EC,list(list(dist=cov.EC[[i]]$dist,parm=list(mean=cov.EC[[i]]$mean,sd=cov.EC[[i]]$sd))))
mean.C  <- c(mean.C, cov.C[[i]]$mean)
mean.EC <- c(mean.EC,cov.EC[[i]]$mean)
}else if(cov.C[[i]]$dist=="binom"){
marg.C  <- append(marg.C, list(list(dist=cov.C[[i]]$dist, parm=list(size=1,prob=cov.C[[i]]$prob))))
marg.EC <- append(marg.EC,list(list(dist=cov.EC[[i]]$dist,parm=list(size=1,prob=cov.EC[[i]]$prob))))
mean.C  <- c(mean.C, cov.C[[i]]$prob)
mean.EC <- c(mean.EC,cov.EC[[i]]$prob)
}
}
int.C   <- out.mean.CC-sum(mean.C*cov.effect.C)
int.EC  <- out.mean.EC-sum(mean.EC*cov.effect.EC)
t.theta <- out.mean.CT-out.mean.CC
cvec.C  <- cov.cor.C[lower.tri(cov.cor.C)]
cvec.EC <- cov.cor.EC[lower.tri(cov.cor.EC)]
data.cov.CT  <- datagen(margdist=marg.C, corvec=cvec.C, nsim=n.CT)
datagen <- function(margdist,corvec,nsim)
{
varnum <- length(margdist)
cormat <- copula::normalCopula(param=corvec,dim=varnum,dispstr="un")
dist <- NULL
parm <- NULL
for(i in 1:varnum){
dist <- c(dist,(margdist[[i]])$dist)
parm <- append(parm,list((margdist[[i]])$parm))
}
mycop <- copula::mvdc(copula=cormat,margins=dist,paramMargins=parm)
return(copula::rMvdc(nsim,mycop))
}
cvec.C  <- cov.cor.C[lower.tri(cov.cor.C)]
cvec.EC <- cov.cor.EC[lower.tri(cov.cor.EC)]
data.cov.CT  <- datagen(margdist=marg.C, corvec=cvec.C, nsim=n.CT)
data.cov.CC  <- datagen(margdist=marg.C, corvec=cvec.C, nsim=n.CC)
data.cov.ECp <- datagen(margdist=marg.EC,corvec=cvec.EC,nsim=n.ECp)
mu.CT  <- int.C +t.theta+apply(data.cov.CT, 1,function(x){sum(x*cov.effect.C)})
mu.CC  <- int.C         +apply(data.cov.CC, 1,function(x){sum(x*cov.effect.C)})
mu.ECp <- int.EC        +apply(data.cov.ECp,1,function(x){sum(x*cov.effect.EC)})
data.CT  <- cbind(rnorm(n.CT, mean=mu.CT, sd=out.sd.CT),data.cov.CT)
data.CC  <- cbind(rnorm(n.CC, mean=mu.CC, sd=out.sd.CC),data.cov.CC)
data.ECp <- cbind(rnorm(n.ECp,mean=mu.ECp,sd=out.sd.EC),data.cov.ECp)
data.CT
outdata <- rbind(
data.frame(study=1,treat=1,y=data.CT[,1], data.CT[,-1]),
data.frame(study=1,treat=0,y=data.CC[,1], data.CC[,-1]),
data.frame(study=0,treat=0,y=data.ECp[,1],data.ECp[,-1]))
outdata
outdata
ncov
indata <- list(data=outdata,ncov=ncov)
n.EC
n.EC <- 50
method.whomatch <- "conc.treat"
method.matching <- "optimal"
method.psorder  <- NULL
method.psest="glm"
method.pslink="logit"
cov.lab  <- paste("X",1:indata$ncov,sep="")
data.cov <- data.frame(indata$data[,c("study","treat",cov.lab)],
conc.contl=0,conc.treat=0,conc.all=0,treat2contl=0)
CT.flg <- (data.cov$study==1)&(data.cov$treat==1)
CC.flg <- (data.cov$study==1)&(data.cov$treat==0)
data.cov[CT.flg,"conc.contl"]  <- 99
data.cov[CT.flg,"conc.treat"]  <- 1
data.cov[CT.flg,"conc.all"]    <- 1
data.cov[CT.flg,"treat2contl"] <- 1
data.cov[CC.flg,"conc.contl"]  <- 1
data.cov[CC.flg,"conc.treat"]  <- 99
data.cov[CC.flg,"conc.all"]    <- 1
data.cov[CC.flg,"treat2contl"] <- 0
fit.ps <- MatchIt::matchit(study~.,
data     = data.cov[,c("study",cov.lab)],
method   = NULL,
distance = method.psest,
link     = method.pslink)
data.cov.ps <- data.frame(data.cov,ps=as.vector(fit.ps$distance))
match.pts  <- (data.cov.ps[,method.whomatch]!=99)
data.match <- data.cov.ps[match.pts,c(method.whomatch,cov.lab)]
colnames(data.match) <- c("match",cov.lab)
if(method.whomatch=="conc.contl"){
n.CC  <- sum(CC.flg)
ratio <- n.EC/n.CC
if(method.matching=="optimal"){
fit.match <- MatchIt::matchit(match~.,
data     = data.match,
method   = method.matching,
distance = data.cov.ps[match.pts,"ps"],
ratio    = ratio)
subjid.EC <- as.numeric(fit.match$match.matrix)
}else if(method.matching=="nearest"){
fit.match <- MatchIt::matchit(match~.,
data     = data.match,
method   = method.matching,
distance = data.cov.ps[match.pts,"ps"],
m.order  = method.psorder,
ratio    = ratio)
subjid.EC <- as.numeric(fit.match$match.matrix)
}
}else if((method.whomatch=="conc.treat")|(method.whomatch=="conc.all")){
if(method.matching=="optimal"){
fit.match <- MatchIt::matchit(match~.,
data     = data.match,
method   = method.matching,
distance = data.cov.ps[match.pts,"ps"])
subjid.EC <- sample(as.numeric(fit.match$match.matrix),n.EC)
}else if(method.matching=="nearest"){
ps.M1 <- data.cov.ps[data.cov.ps[,method.whomatch]==1,"ps"]
ps.M0 <- data.cov.ps[data.cov.ps[,method.whomatch]==0,"ps"]
ps.M  <- sort(abs(apply(as.matrix(ps.M1),1,function(x){x-ps.M0})))
ncal <- n.EC
while(1){
fit.match <- MatchIt::matchit(match~.,
data        = data.match,
method      = method.matching,
distance    = data.cov.ps[match.pts,"ps"],
m.order     = method.psorder,
caliper     = ps.M[ncal],
std.caliper = FALSE)
if(sum(!is.na(fit.match$match.matrix))>=n.EC){
nearest <- fit.match$match.matrix
break
}else{
ncal <- ncal+1
}
}
subjid.EC <- sample(as.numeric(nearest[!is.na(nearest),]),n.EC)
}
}else if(method.whomatch=="treat2contl"){
if(method.matching=="optimal"){
fit.match <- MatchIt::matchit(match~.,
data     = data.match,
method   = method.matching,
distance = data.cov.ps[match.pts,"ps"])
subjid.C1 <- as.numeric(fit.match$match.matrix)
subjid.C2 <- subjid.C1[data.cov.ps[subjid.C1,"study"]==0]
if(length(subjid.C2)>=n.EC){
subjid.EC <- sample(subjid.C2,n.EC)
}else{
subjid.EC <- subjid.C2
}
}else if(method.matching=="nearest"){
ps.M1 <- data.cov.ps[data.cov.ps[,method.whomatch]==1,"ps"]
ps.M0 <- data.cov.ps[data.cov.ps[,method.whomatch]==0,"ps"]
ps.M  <- sort(abs(apply(as.matrix(ps.M1),1,function(x){x-ps.M0})))
ncal <- n.EC
while(1){
fit.match <- MatchIt::matchit(match~.,
data        = data.match,
method      = method.matching,
distance    = data.cov.ps[match.pts,"ps"],
m.order     = method.psorder,
caliper     = ps.M[ncal],
std.caliper = FALSE)
subjid.C1 <- fit.match$match.matrix
subjid.C2 <- as.numeric(subjid.C1[!is.na(subjid.C1)])
subjid.C3 <- subjid.C2[data.cov.ps[subjid.C2,"study"]==0]
if(length(subjid.C3)>=n.EC){
nearest <- subjid.C3
break
}else{
ncal <- ncal+1
}
}
subjid.EC <- sample(nearest,n.EC)
}
}
list(subjid.EC=subjid.EC,data.cov.ps=data.cov.ps)
data.outp <- indata$data
data.out  <- rbind(data.outp[data.outp$study==1,],data.outp[subjid.EC,])
nmethod    <- length(method.borrow)
ncov      <- indata$ncov
cov.lab   <- paste("X",1:ncov,sep="")
data.outp <- indata$data
data.out  <- rbind(data.outp[data.outp$study==1,],data.outp[subjid.EC,])
data.CT <- data.out[(data.out$study==1)&(data.out$treat==1),c("y",cov.lab)]
data.CC <- data.out[(data.out$study==1)&(data.out$treat==0),c("y",cov.lab)]
data.EC <- data.out[(data.out$study==0)&(data.out$treat==0),c("y",cov.lab)]
data.CT[,1]
data.CT
nrow(data.CT)
nrow(data.CC)
nrow(data.CT)
ncov
nrow(data.EC)
method.borrow[[i]]$scale
nrow(data.EC)
out.mean.CT
out.mean.CC
library(psBayesborrow)
library(psBayesborrow)
source("C:/Users/API18340/OneDrive - Astellas Pharma Inc/03. Non-project/3. A3082/2. R/psBayesborrow/R/commensurate.bin.R")
