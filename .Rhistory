accrual    <- 16
out.mevent.CT <- 6
out.mevent.CC <- 6
driftHR       <- 1
cov.C <- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
list(dist="binom",prob=0.4,lab="cov2"))
cov.cor.C <- rbind(c(  1,0.1),
c(0.1,  1))
cov.EC <- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
list(dist="binom",prob=0.4,lab="cov2"))
cov.cor.EC <- rbind(c(  1,0.1),
c(0.1,  1))
cov.effect <- c(0.9,0.9)
psmatch.cov <- c("cov1","cov2")
method.whomatch <- "conc.treat"
method.matching <- "optimal"
method.psorder  <- NULL
analysis.cov <- c("cov1")
method.borrow <- list(list(prior="noborrow"),
list(prior="normal",scale=0.5))
nsim <- 5
res <- psborrow.t2e(
n.CT=n.CT, n.CC=n.CC, nevent.C=nevent.C,
n.ECp=n.ECp, nevent.ECp=nevent.ECp, n.EC=n.EC, accrual=accrual,
out.mevent.CT=out.mevent.CT, out.mevent.CC=out.mevent.CC, driftHR=driftHR,
cov.C=cov.C, cov.cor.C=cov.cor.C,
cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect=cov.effect,
psmatch.cov=psmatch.cov, method.whomatch=method.whomatch,
method.matching=method.matching, method.psorder=method.psorder,
analysis.cov=analysis.cov, method.borrow=method.borrow,
chains=1, iter=100, nsim=nsim, seed=100)
library(rstan)
res <- psborrow.t2e(
n.CT=n.CT, n.CC=n.CC, nevent.C=nevent.C,
n.ECp=n.ECp, nevent.ECp=nevent.ECp, n.EC=n.EC, accrual=accrual,
out.mevent.CT=out.mevent.CT, out.mevent.CC=out.mevent.CC, driftHR=driftHR,
cov.C=cov.C, cov.cor.C=cov.cor.C,
cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect=cov.effect,
psmatch.cov=psmatch.cov, method.whomatch=method.whomatch,
method.matching=method.matching, method.psorder=method.psorder,
analysis.cov=analysis.cov, method.borrow=method.borrow,
chains=1, iter=100, nsim=nsim, seed=100)
commensurate.t2e(
survival::Surv(time,status)~cov1+cov2,data=indata.match,
method.borrow=method.borrow,chains=1,iter=100)
n.CT       <- 100
n.CC       <- 50
nevent.C   <- 100
n.ECp      <- 200
nevent.ECp <- 180
accrual    <- 16
out.mevent.CT <- 6
out.mevent.CC <- 6
driftHR       <- 1
cov.C <- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
list(dist="binom",prob=0.4,lab="cov2"))
cov.cor.C <- rbind(c(  1,0.1),
c(0.1,  1))
cov.EC <- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
list(dist="binom",prob=0.4,lab="cov2"))
cov.cor.EC <- rbind(c(  1,0.1),
c(0.1,  1))
cov.effect <- c(0.9,0.9)
indata <- trial.simulation.t2e(
n.CT=n.CT, n.CC=n.CC, nevent.C=nevent.C,
n.ECp=n.ECp, nevent.ECp=nevent.ECp, accrual=accrual,
out.mevent.CT, out.mevent.CC, driftHR,
cov.C=cov.C, cov.cor.C=cov.cor.C,
cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect=cov.effect)
n.EC <- 50
method.whomatch <- "conc.treat"
method.matching <- "optimal"
method.psorder  <- NULL
out.psmatch <- psmatch(
study~cov1+cov2, data=indata, n.EC=n.EC,
method.whomatch=method.whomatch, method.matching=method.matching,
method.psorder=method.psorder)
indata.match <- rbind(indata[indata$study==1,],indata[out.psmatch$subjid.EC,])
method.borrow <- list(list(prior="cauchy",scale=2.0),
list(prior="normal",scale=0.5))
commensurate.t2e(
survival::Surv(time,status)~cov1+cov2,data=indata.match,
method.borrow=method.borrow,chains=1,iter=100)
formula <- survival::Surv(time,status)~cov1+cov2
data<-indata.match
method.borrow=method.borrow
chains=1
iter=100
chains=2
iter=4000
warmup=floor(iter/2)
thin=1
sig.level=0.025
alternative="greater"
seed=sample.int(.Machine$integer.max,1)
mf      <- stats::model.frame(formula=formula,data=data)
cov.lab <- attr(attr(mf,"terms"),"term.labels")
y       <- stats::model.response(mf)
if(!survival::is.Surv(y)){
stop("Outcome must be Surv class.")
}else if(length(data$study)==0){
stop("Dataset must contain a variable of study.")
}else if(length(data$treat)==0){
stop("Dataset must contain a variable of treat.")
}else{
ncov     <- length(cov.lab)
data.out <- data.frame(y      = as.vector(y[,1]),
censor = 1-as.vector(y[,2]),
study  = data$study,
treat  = data$treat,
data[,cov.lab,drop=FALSE])
censor.CT <- data.out[(data.out$study==1)&(data.out$treat==1),"censor"]
data.CT   <- data.out[(data.out$study==1)&(data.out$treat==1),c("y",cov.lab),drop=FALSE]
censor.CC <- data.out[(data.out$study==1)&(data.out$treat==0),"censor"]
data.CC   <- data.out[(data.out$study==1)&(data.out$treat==0),c("y",cov.lab),drop=FALSE]
censor.EC <- data.out[(data.out$study==0)&(data.out$treat==0),"censor"]
data.EC   <- data.out[(data.out$study==0)&(data.out$treat==0),c("y",cov.lab),drop=FALSE]
nmethod    <- length(method.borrow)
method.lab <- character(nmethod)
reject <- data.frame(X0="reject")
theta  <- data.frame(X0=c("mean","median","sd","lcri","ucri"))
stan.obj <- NULL
for(i in 1:nmethod){
if(method.borrow[[i]]$prior=="noborrow"){
dat <- list(
nCT_o = sum(censor.CT==0),
nCT_c = sum(censor.CT==1),
nCC_o = sum(censor.CC==0),
nCC_c = sum(censor.CC==1),
p     = ncov,
yCT_o = as.array(data.CT[censor.CT==0,"y"]),
yCT_c = as.array(data.CT[censor.CT==1,"y"]),
yCC_o = as.array(data.CC[censor.CC==0,"y"]),
yCC_c = as.array(data.CC[censor.CC==1,"y"]),
xCT_o = as.matrix(data.CT[censor.CT==0,cov.lab,drop=FALSE]),
xCT_c = as.matrix(data.CT[censor.CT==1,cov.lab,drop=FALSE]),
xCC_o = as.matrix(data.CC[censor.CC==0,cov.lab,drop=FALSE]),
xCC_c = as.matrix(data.CC[censor.CC==1,cov.lab,drop=FALSE]))
mcmc <- rstan::sampling(stanmodels$T2ENoborrow,
data          = dat,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0,
seed          = seed)
mcmc.sample <- rstan::extract(mcmc)
}else if(method.borrow[[i]]$prior=="fullborrow"){
dat <- list(
nCT_o = sum(censor.CT==0),
nCT_c = sum(censor.CT==1),
nCC_o = sum(censor.CC==0),
nCC_c = sum(censor.CC==1),
nEC_o = sum(censor.EC==0),
nEC_c = sum(censor.EC==1),
p     = ncov,
yCT_o = as.array(data.CT[censor.CT==0,"y"]),
yCT_c = as.array(data.CT[censor.CT==1,"y"]),
yCC_o = as.array(data.CC[censor.CC==0,"y"]),
yCC_c = as.array(data.CC[censor.CC==1,"y"]),
yEC_o = as.array(data.EC[censor.EC==0,"y"]),
yEC_c = as.array(data.EC[censor.EC==1,"y"]),
xCT_o = as.matrix(data.CT[censor.CT==0,cov.lab,drop=FALSE]),
xCT_c = as.matrix(data.CT[censor.CT==1,cov.lab,drop=FALSE]),
xCC_o = as.matrix(data.CC[censor.CC==0,cov.lab,drop=FALSE]),
xCC_c = as.matrix(data.CC[censor.CC==1,cov.lab,drop=FALSE]),
xEC_o = as.matrix(data.EC[censor.EC==0,cov.lab,drop=FALSE]),
xEC_c = as.matrix(data.EC[censor.EC==1,cov.lab,drop=FALSE]))
mcmc <- rstan::sampling(stanmodels$T2EFullborrow,
data          = dat,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0,
seed          = seed)
mcmc.sample <- rstan::extract(mcmc)
}else if(method.borrow[[i]]$prior=="cauchy"){
dat <- list(
nCT_o = sum(censor.CT==0),
nCT_c = sum(censor.CT==1),
nCC_o = sum(censor.CC==0),
nCC_c = sum(censor.CC==1),
nEC_o = sum(censor.EC==0),
nEC_c = sum(censor.EC==1),
p     = ncov,
yCT_o = as.array(data.CT[censor.CT==0,"y"]),
yCT_c = as.array(data.CT[censor.CT==1,"y"]),
yCC_o = as.array(data.CC[censor.CC==0,"y"]),
yCC_c = as.array(data.CC[censor.CC==1,"y"]),
yEC_o = as.array(data.EC[censor.EC==0,"y"]),
yEC_c = as.array(data.EC[censor.EC==1,"y"]),
xCT_o = as.matrix(data.CT[censor.CT==0,cov.lab,drop=FALSE]),
xCT_c = as.matrix(data.CT[censor.CT==1,cov.lab,drop=FALSE]),
xCC_o = as.matrix(data.CC[censor.CC==0,cov.lab,drop=FALSE]),
xCC_c = as.matrix(data.CC[censor.CC==1,cov.lab,drop=FALSE]),
xEC_o = as.matrix(data.EC[censor.EC==0,cov.lab,drop=FALSE]),
xEC_c = as.matrix(data.EC[censor.EC==1,cov.lab,drop=FALSE]),
scale = method.borrow[[i]]$scale)
mcmc <- rstan::sampling(stanmodels$T2ECauchy,
data          = dat,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0,
seed          = seed)
mcmc.sample <- rstan::extract(mcmc)
}else if(method.borrow[[i]]$prior=="normal"){
dat <- list(
nCT_o = sum(censor.CT==0),
nCT_c = sum(censor.CT==1),
nCC_o = sum(censor.CC==0),
nCC_c = sum(censor.CC==1),
nEC_o = sum(censor.EC==0),
nEC_c = sum(censor.EC==1),
p     = ncov,
yCT_o = as.array(data.CT[censor.CT==0,"y"]),
yCT_c = as.array(data.CT[censor.CT==1,"y"]),
yCC_o = as.array(data.CC[censor.CC==0,"y"]),
yCC_c = as.array(data.CC[censor.CC==1,"y"]),
yEC_o = as.array(data.EC[censor.EC==0,"y"]),
yEC_c = as.array(data.EC[censor.EC==1,"y"]),
xCT_o = as.matrix(data.CT[censor.CT==0,cov.lab,drop=FALSE]),
xCT_c = as.matrix(data.CT[censor.CT==1,cov.lab,drop=FALSE]),
xCC_o = as.matrix(data.CC[censor.CC==0,cov.lab,drop=FALSE]),
xCC_c = as.matrix(data.CC[censor.CC==1,cov.lab,drop=FALSE]),
xEC_o = as.matrix(data.EC[censor.EC==0,cov.lab,drop=FALSE]),
xEC_c = as.matrix(data.EC[censor.EC==1,cov.lab,drop=FALSE]),
scale = method.borrow[[i]]$scale)
mcmc <- rstan::sampling(stanmodels$T2ENormal,
data          = dat,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0,
seed          = seed)
mcmc.sample <- rstan::extract(mcmc)
}
loghr <- mcmc.sample$theta
if(alternative=="greater"){
postprob <- mean(loghr>0)
}else if(alternative=="less"){
postprob <- mean(loghr<0)
}
cri <- stats::quantile(loghr,c(sig.level,1-sig.level))
reject.v <- (postprob>(1-sig.level))
reject   <- data.frame(reject,X1=reject.v)
theta.v <- c(mean(loghr),stats::median(loghr),stats::sd(loghr),cri[[1]],cri[[2]])
theta   <- data.frame(theta,X1=theta.v)
mname <- method.borrow[[i]]$prior
if((mname=="noborrow")|(mname=="fullborrow")){
method.lab[i] <- mname
}else if((mname=="cauchy")|(mname=="normal")){
method.lab[i] <- paste(mname,method.borrow[[i]]$scale,sep="")
}
stan.obj <- append(stan.obj,list(mcmc))
}
colnames(reject) <- c("measure",method.lab)
colnames(theta)  <- c("measure",method.lab)
names(stan.obj)  <- method.lab
return(list(reject=reject,theta=theta,stan.obj=stan.obj))
}
sampling
ncov     <- length(cov.lab)
data.out <- data.frame(y      = as.vector(y[,1]),
censor = 1-as.vector(y[,2]),
study  = data$study,
treat  = data$treat,
data[,cov.lab,drop=FALSE])
censor.CT <- data.out[(data.out$study==1)&(data.out$treat==1),"censor"]
data.CT   <- data.out[(data.out$study==1)&(data.out$treat==1),c("y",cov.lab),drop=FALSE]
censor.CC <- data.out[(data.out$study==1)&(data.out$treat==0),"censor"]
data.CC   <- data.out[(data.out$study==1)&(data.out$treat==0),c("y",cov.lab),drop=FALSE]
censor.EC <- data.out[(data.out$study==0)&(data.out$treat==0),"censor"]
data.EC   <- data.out[(data.out$study==0)&(data.out$treat==0),c("y",cov.lab),drop=FALSE]
nmethod    <- length(method.borrow)
method.lab <- character(nmethod)
reject <- data.frame(X0="reject")
theta  <- data.frame(X0=c("mean","median","sd","lcri","ucri"))
stan.obj <- NULL
i
method.borrow[[i]]$prior
dat <- list(
nCT_o = sum(censor.CT==0),
nCT_c = sum(censor.CT==1),
nCC_o = sum(censor.CC==0),
nCC_c = sum(censor.CC==1),
nEC_o = sum(censor.EC==0),
nEC_c = sum(censor.EC==1),
p     = ncov,
yCT_o = as.array(data.CT[censor.CT==0,"y"]),
yCT_c = as.array(data.CT[censor.CT==1,"y"]),
yCC_o = as.array(data.CC[censor.CC==0,"y"]),
yCC_c = as.array(data.CC[censor.CC==1,"y"]),
yEC_o = as.array(data.EC[censor.EC==0,"y"]),
yEC_c = as.array(data.EC[censor.EC==1,"y"]),
xCT_o = as.matrix(data.CT[censor.CT==0,cov.lab,drop=FALSE]),
xCT_c = as.matrix(data.CT[censor.CT==1,cov.lab,drop=FALSE]),
xCC_o = as.matrix(data.CC[censor.CC==0,cov.lab,drop=FALSE]),
xCC_c = as.matrix(data.CC[censor.CC==1,cov.lab,drop=FALSE]),
xEC_o = as.matrix(data.EC[censor.EC==0,cov.lab,drop=FALSE]),
xEC_c = as.matrix(data.EC[censor.EC==1,cov.lab,drop=FALSE]),
scale = method.borrow[[i]]$scale)
mcmc <- rstan::sampling(stanmodels$T2ECauchy,
data          = dat,
chains        = chains,
iter          = iter,
warmup        = warmup,
thin          = thin,
show_messages = FALSE,
cores         = 1,
refresh       = 0,
seed          = seed)
stanmodels$T2ECauchy
devtools::check_rhub()
rhub::validate_email()
rhub::validate_email()
devtools::check_rhub()
list_validated_emails()
devtools::list_validated_emails()
rhub::list_validated_emails()
devtools::check_rhub(email="yamagubed@gmail.com")
rhub::list_my_checks(email="yamagubed@gmail.com")
rhub::list_my_checks()
list_validated_emails()
rhub::list_validated_emails()
validate_email(email="yamagubed@gmail.com",token="6f3db9cff36347a9a6fa78ae85f7e72")
rhub::validate_email(email="yamagubed@gmail.com",token="6f3db9cff36347a9a6fa78ae85f7e72")
rhub::list_my_checks(email="yamagubed@gmail.com")
rhub::list_my_checks()
whoami::email_address()
rhub::validate_email(email="yusuke-yamaguchi@astellas.com",token="646535c452114fc0b95af128b65aa870")
rhub::list_my_checks()
devtools::check_rhub()
devtools::release()
devtools::release()
library(testthat)
library(psBayesborrow)
n.CT       <- 100
n.CC       <- 50
nevent.C   <- 100
n.ECp      <- 200
nevent.ECp <- 180
n.EC       <- 50
accrual    <- 16
out.mevent.CT <- 6
out.mevent.CC <- 6
driftHR       <- 1
cov.C <- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
list(dist="binom",prob=0.4,lab="cov2"))
cov.cor.C <- rbind(c(  1,0.1),
c(0.1,  1))
cov.EC <- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
list(dist="binom",prob=0.4,lab="cov2"))
cov.cor.EC <- rbind(c(  1,0.1),
c(0.1,  1))
cov.effect <- c(0.9,0.9)
psmatch.cov <- c("cov1","cov2")
method.whomatch <- "conc.treat"
method.matching <- "optimal"
method.psorder  <- NULL
analysis.cov <- c("cov1")
method.borrow <- list(list(prior="noborrow"),
list(prior="normal",scale=0.5))
nsim <- 5
res <- psborrow.t2e(
n.CT=n.CT, n.CC=n.CC, nevent.C=nevent.C,
n.ECp=n.ECp, nevent.ECp=nevent.ECp, n.EC=n.EC, accrual=accrual,
out.mevent.CT=out.mevent.CT, out.mevent.CC=out.mevent.CC, driftHR=driftHR,
cov.C=cov.C, cov.cor.C=cov.cor.C,
cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect=cov.effect,
psmatch.cov=psmatch.cov, method.whomatch=method.whomatch,
method.matching=method.matching, method.psorder=method.psorder,
analysis.cov=analysis.cov, method.borrow=method.borrow,
chains=1, iter=100, nsim=nsim, seed=100)
rj1.sim <- res$reject[,"noborrow"]
rj2.sim <- res$reject[,"normal0.5"]
th1.sim <- ceiling(100*res$theta[,"noborrow"])/100
th2.sim <- ceiling(100*res$theta[,"normal0.5"])/100
ov.sim  <- ceiling(100*res$ov[,"ov"])/100
rj1.sim
rj2.sim
th1.sim
th2.sim
ov.sim
rj1.sim <- res$reject[,"noborrow"]
rj2.sim <- res$reject[,"normal0.5"]
th1.sim <- ceiling(100*res$theta[,"noborrow"])/100
th2.sim <- ceiling(100*res$theta[,"normal0.5"])/100
ov.sim  <- ceiling(100*res$ov[,"ov"])/100
rj1.exp <- c(FALSE,FALSE,FALSE,FALSE,FALSE)
rj2.exp <- c( TRUE,FALSE,FALSE,FALSE,FALSE)
th1.exp <- c(
0.40,0.39,0.27,-0.07,0.87,-0.06,-0.07,0.20,-0.40,0.25,-0.25,-0.22,0.17,-0.68,-0.04,-0.02,-0.01,0.19,-0.40,
0.30,-0.10,-0.09,0.18,-0.44,0.18)
th2.exp <- c(
0.27,0.26,0.15,0.01,0.50,-0.06,-0.05,0.27,-0.59,0.34,-0.22,-0.20,0.17,-0.56,0.09,-0.06,-0.07,0.16,-0.39,
0.23,-0.18,-0.14,0.20,-0.54,0.12)
ov.exp <- c(
0.90,0.85,0.04,0.87,0.76,-0.01,0.97,0.93,0.00,0.87,0.93,-0.03,0.96,0.91,0.06,0.84,0.86,-0.15,0.91,
0.91,-0.07,0.93,0.89,0.04,0.97,0.92,0.05,0.92,0.95,-0.08)
test_that("Check psBayesborrow simulation results",{
expect_identical(rj1.sim,rj1.exp)
expect_identical(rj2.sim,rj2.exp)
expect_identical(th1.sim,th1.exp)
expect_identical(th2.sim,th2.exp)
expect_identical(ov.sim,  ov.exp)
})
test_check("psBayesborrow")
library(testthat)
library(psBayesborrow)
test_check("psBayesborrow")
n.CT       <- 100
n.CC       <- 50
nevent.C   <- 100
n.ECp      <- 1000
nevent.ECp <- 800
accrual    <- 16
out.mevent.CT <- 6
out.mevent.CC <- 6
driftHR       <- 1
cov.C <- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
list(dist="binom",prob=0.4,lab="cov2"))
cov.cor.C <- rbind(c(  1,0.1),
c(0.1,  1))
cov.EC <- list(list(dist="norm",mean=0,sd=1,lab="cov1"),
list(dist="binom",prob=0.4,lab="cov2"))
cov.cor.EC <- rbind(c(  1,0.1),
c(0.1,  1))
cov.effect <- c(0.1,0.1)
indata <- trial.simulation.t2e(
n.CT=n.CT, n.CC=n.CC, nevent.C=nevent.C,
n.ECp=n.ECp, nevent.ECp=nevent.ECp, accrual=accrual,
out.mevent.CT, out.mevent.CC, driftHR,
cov.C=cov.C, cov.cor.C=cov.cor.C,
cov.EC=cov.EC, cov.cor.EC=cov.cor.EC, cov.effect=cov.effect)
n.EC <- 50
method.whomatch <- "conc.treat"
method.matching <- "optimal"
method.psorder  <- NULL
psmatch(
study~cov1+cov2, data=indata, n.EC=n.EC,
method.whomatch=method.whomatch, method.matching=method.matching,
method.psorder=method.psorder)
mypsmatch <- psmatch(
study~cov1+cov2, data=indata, n.EC=n.EC,
method.whomatch=method.whomatch, method.matching=method.matching,
method.psorder=method.psorder)
mypsmatch
mypsmatch$subjid.EC
mypsmatch <- psmatch(
study~cov1+cov2, data=indata, n.EC=n.EC,
method.whomatch=method.whomatch, method.matching=method.matching,
method.psorder=method.psorder)
mypsmatch$subjid.EC
method.whomatch <- "conc.treat"
method.matching <- "nearest"
method.psorder  <- NULL
mypsmatch <- psmatch(
study~cov1+cov2, data=indata, n.EC=n.EC,
method.whomatch=method.whomatch, method.matching=method.matching,
method.psorder=method.psorder)
mypsmatch$subjid.EC
method.whomatch <- "conc.contl"
method.matching <- "nearest"
method.psorder  <- "large"
mypsmatch <- psmatch(
study~cov1+cov2, data=indata, n.EC=n.EC,
method.whomatch=method.whomatch, method.matching=method.matching,
method.psorder=method.psorder)
mypsmatch$subjid.EC
method.whomatch <- "conc.contl"
method.matching <- "nearest"
method.psorder  <- "large"
mypsmatch <- psmatch(
study~cov1+cov2, data=indata, n.EC=n.EC,
method.whomatch=method.whomatch, method.matching=method.matching,
method.psorder=method.psorder)
mypsmatch$subjid.EC
method.whomatch <- "conc.contl"
method.matching <- "nearest"
method.psorder  <- "large"
mypsmatch <- psmatch(
study~cov1+cov2, data=indata, n.EC=n.EC,
method.whomatch=method.whomatch, method.matching=method.matching,
method.psorder=method.psorder)
mypsmatch$subjid.EC
subjid.EC.run <- mypsmatch$subjid.EC
subjid.EC.exp <- c(
605,822,943,849,705,725,1080,797,971,498,1063,1147,339,873,731,1055,451,846,874,
543,847,1029,414,552,445,1037,678,205,1142,955,1119,904,511,800,692,657,702,1056,
665,972,273,272,233,940,196,180,578,1062,973,386)
test_that("Check psmatch results",{
expect_identical(subjid.EC.run,subjid.EC.exp)
})
library(psBayesborrow)
library(psBayesborrow)
results <- rhub::check_for_cran()
results$cran_summary()
results$cran_summary()
results$cran_summary()
results$cran_summary()
